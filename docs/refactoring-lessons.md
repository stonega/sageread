# 代码重构方法论

## 方法论 1：单一配置源模式

**识别信号：** 复制粘贴代码 / 3+ 处相同逻辑

**解决方案：** 创建统一的配置函数

```typescript
// ❌ Bad: 分散在各处
const config = { /* 重复逻辑 */ };

// ✅ Good: 单一来源
const config = await getCurrentConfig();
```

**原则：** DRY + Single Source of Truth

---

## 方法论 2：职责边界清晰化

**识别信号：** 前后端都在做相同处理

**解决方案：** 前端处理 → 后端使用

```typescript
// ✅ 前端：规范化、验证、准备
const url = normalizeUrl(input);
backend.call(url);

// ✅ 后端：直接使用
fn process(url: String) { ... }
```

**原则：** Separation of Concerns

---

## 方法论 3：命名一致性

**识别信号：** 同一概念多个名字 / 命名模糊

**解决方案：**
- 语义明确：`embeddingsUrl` 而非 `url`
- 风格统一：前端 `camelCase` / 后端 `snake_case`
- 一个概念一个名字

**原则：** 命名即文档

---

## 方法论 4：缓存昂贵操作

**识别信号：** 相同操作执行多次 / 性能问题

**解决方案：**
```typescript
// 提前执行 + 缓存
onToggle(async () => {
  const result = await expensive();
  saveToConfig({ result });
});

// 使用时直接读取
const result = config.result || default;
```

**原则：** 让错误尽早暴露

---

## 方法论 5：渐进式重构

**三步走：**
1. 修复表面问题 → 让代码能工作
2. 质疑设计 → 为什么重复？
3. 重构核心 → 提取公共逻辑

**原则：** 小步快跑，迭代优于重写

---

## 方法论 6：代码审查质疑清单

**5 个关键问题：**
1. 是否有重复？
2. 职责是否清晰？
3. 命名是否准确？
4. 边界是否清晰？
5. 能否更简单？

**原则：** 从"能工作"到"设计优雅"

---

## 架构原则速查

| 原则 | 实践 |
|------|------|
| **DRY** | 提取公共函数 |
| **SRP** | 一个函数只做一件事 |
| **SOT** | 统一的配置来源 |
| **SoC** | 前后端职责分离 |
| **KISS** | 优先简单方案 |

---

## 应用步骤

1. 识别问题（使用"识别信号"）
2. 选择方法论
3. 应用方案
4. 验证效果
5. 记录新方法论